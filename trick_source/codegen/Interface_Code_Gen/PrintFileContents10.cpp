
#include <sstream>

#include "PrintFileContents10.hh"
#include "FieldDescription.hh"
#include "ClassValues.hh"
#include "EnumValues.hh"
#include "Utilities.hh"

extern llvm::cl::opt< bool > global_compat15 ;

PrintFileContents10::PrintFileContents10() {}

/** Prints the io_src header information */
void PrintFileContents10::printIOHeader(std::ostream & ostream , std::string header_file_name) {

     if ( ! header_file_name.compare("S_source.hh") ) {
         header_file_name = "../S_source.hh" ;
     } else {
         header_file_name = almostRealPath(header_file_name.c_str()) ;
     }
     ostream <<
"/**\n"
" * This file was automatically generated by the ICG based on the file:\n"
" * " << header_file_name << "\n"
" * This file contains database parameter declarations specific to the\n"
" * data structures and enumerated types declared in the above file.\n"
" * These database parameters are used by the Trick input and\n"
" * data recording processors to gain access to important simulation\n"
" * variable information.\n"
" */\n"
"\n"
"#define TRICK_IN_IOSRC\n"
"#include <stdlib.h>\n"
"#include \"trick/MemoryManager.hh\"\n"
"#include \"trick/attributes.h\"\n"
"#include \"trick/parameter_types.h\"\n"
"#include \"trick/ClassSizeCheck.hh\"\n"
"#include \"trick/UnitsMap.hh\"\n"
"#include \"trick/checkpoint_stl.hh\"\n"
"#include \"" << header_file_name << "\"\n"
"\n" ;

}

/** Prints enumeration attributes */
void PrintFileContents10::print_enum_attr(std::ostream & ostream , EnumValues * e ) {
    print_open_extern_c(ostream) ;
    ostream << "ENUM_ATTR enum" ;
    printNamespaces( ostream, e , "__" ) ;
    printContainerClasses( ostream, e , "__" ) ;
    ostream << e->getName() << "[] = {\n" ;
    for ( EnumValues::NameValueIterator nvit = e->begin() ; nvit != e->end() ; nvit++ ) {
        ostream << "{\"";
        printNamespaces( ostream, e , "::" ) ;
        printContainerClasses( ostream, e , "::" ) ;
        ostream << (*nvit).first << "\" , " << (*nvit).second << " , 0x0 } ,\n" ;
    }
    ostream << "{\"\" , 0 , 0x0 }\n} ;\n" ;
    print_close_extern_c(ostream) ;
}

/** Prints attributes for a field */
void PrintFileContents10::print_field_attr(std::ostream & ostream ,  FieldDescription * fdes ) {
    int array_dim ;

    ostream << "{ \"" << fdes->getName() << "\"" ;        // name
    ostream << ", \"" ;                                   // start type_name
    printNamespaces( ostream, fdes , "__" ) ;
    printContainerClasses( ostream, fdes , "__" ) ;
    ostream << fdes->getMangledTypeName() << "\"";        // end type_name
    ostream << ", \"" << fdes->getUnits() << "\"" ;       // units
    ostream << ", \"\", \"\"," << std::endl ;           // alias , user_defined
    ostream << "  \"" << fdes->getDescription() << "\"," << std::endl ; // description
    ostream << "  " << fdes->getIO() ;                    // io
    ostream << "," << fdes->getEnumString() ;             // type
    // There are several cases when printing the size of a variable.
    if ( fdes->isBitField() ) {
        // bitfields are handled in 4 byte (32 bit) chunks
        ostream << ",4" ;
    } else if (  fdes->isRecord() or fdes->isEnum() or fdes->getTypeName().empty() ) {
        // records enums use io_src_get_size. The sentinel has no typename
        ostream << ",0" ;
    } else {
        // print size of the underlying type
        ostream << ",sizeof(" << fdes->getTypeName() << ")" ;
    }
    ostream << ",0,0,Language_CPP" ; // range_min, range_max, language
    ostream << "," << (fdes->isStatic() << 1) + (fdes->isDashDashUnits() << 2) << "," << std::endl ; // mods
    if ( fdes->isBitField() ) {
        // For bitfields we need the offset to start on 4 byte boundaries because that is what our
        // insert and extract bitfield routines work with.
        ostream << "  " << (fdes->getFieldOffset() - (fdes->getFieldOffset() % 32)) / 8 ; // offset
    } else {
        ostream << "  " << (fdes->getFieldOffset() / 8) ; // offset
    }
    ostream << ",NULL" ; // attr
    ostream << "," << fdes->getNumDims() ;                // num_index

    ostream << ",{" ;
    if ( fdes->isBitField() ) {
        ostream << "{" << fdes->getBitFieldWidth() ; // size of bitfield
        ostream << "," << 32 - (fdes->getFieldOffset() % 32) - fdes->getBitFieldWidth() << "}" ; // start bit
    } else {
        array_dim = fdes->getArrayDim(0) ;
        if ( array_dim < 0 ) array_dim = 0 ;
        ostream << "{" << array_dim << ",0}" ; // index 0
    }
    unsigned int ii ;
    for ( ii = 1 ; ii < 8 ; ii++ ) {
        array_dim = fdes->getArrayDim(ii) ;
        if ( array_dim < 0 ) array_dim = 0 ;
        ostream << ",{" << array_dim << ",0}" ; // indexes 1 through 7
    }
    ostream << "}," << std::endl ;
    ostream << "  NULL, NULL, NULL, NULL" ;
    ostream << "}" ;
}

/** Prints class attributes */
void PrintFileContents10::print_class_attr(std::ostream & ostream , ClassValues * c ) {

    unsigned int ii ;
    ClassValues::FieldIterator fit ;

    print_open_extern_c(ostream) ;
    ostream << "ATTRIBUTES attr" ;
    printNamespaces( ostream, c , "__" ) ;
    printContainerClasses( ostream, c , "__" ) ;
    ostream << c->getMangledTypeName() ;
    ostream << "[] = {" << std::endl ;

    for ( fit = c->field_begin() ; fit != c->field_end() ; fit++ ) {
        if ( determinePrintAttr(c , *fit) ) {
            print_field_attr(ostream, *fit) ;
            ostream << "," << std::endl ;
        }
    }
    // Print an empty sentinel attribute at the end of the class.
    FieldDescription * new_fdes = new FieldDescription(std::string("")) ;
    print_field_attr(ostream, new_fdes) ;
    ostream << " };" << std::endl ;
    delete new_fdes ;

    print_close_extern_c(ostream) ;
}

/** Prints init_attr function for each class */
void PrintFileContents10::print_field_init_attr_stmts( std::ostream & ostream , FieldDescription * fdes ,
 ClassValues * cv , unsigned int index ) {

    // For static variables replace the offset field with the address of the static variable
    if ( global_compat15 or cv->isCompat15()) {
        if ( fdes->isStatic() ) {
            // print a special offsetof statement if this is a static
            ostream << "    attr" ;
            printNamespaces( ostream, cv , "__" ) ;
            printContainerClasses( ostream, cv , "__" ) ;
            ostream << cv->getMangledTypeName() << "[" << index << "].offset = (long)(void *)&" ;
            printNamespaces( ostream, cv , "::" ) ;
            printContainerClasses( ostream, cv , "::" ) ;
            ostream << cv->getName() << "::" << fdes->getName() << " ;\n" ;
        } else if ( fdes->isBitField() ) {
            // else if this is a bitfield
            ostream << "    attr" ;
            printNamespaces( ostream, cv , "__" ) ;
            printContainerClasses( ostream, cv , "__" ) ;
            ostream << cv->getMangledTypeName() << "[" << index << "].offset = " ;
            ostream << fdes->getBitFieldByteOffset() << " ;\n" ;
            // All bitfield offsets are in terms of unsigned ints.
            ostream << "    attr" ;
            printNamespaces( ostream, cv , "__" ) ;
            printContainerClasses( ostream, cv , "__" ) ;
            ostream << cv->getMangledTypeName() << "[" << index << "].size = sizeof(unsigned int) ;\n" ;
        } else if ( fdes->isVirtualInherited() ) {
            // else if we have a virtually inherited class.
            ostream << "    attr" ;
            printNamespaces( ostream, cv , "__" ) ;
            printContainerClasses( ostream, cv , "__" ) ;
            ostream << cv->getMangledTypeName() << "[" << index << "].offset = " << fdes->getBaseClassOffset() ;
            ostream << " + offsetof(" ;
            ostream << fdes->getContainerClass() << "," << fdes->getName() << ") ;\n" ;
        } else if ( cv->getMangledTypeName() != cv->getName() ) {
            // else if we have a template type where mangled_type_name is different then name.
            ostream << "    attr" ;
            printNamespaces( ostream, cv , "__" ) ;
            printContainerClasses( ostream, cv , "__" ) ;
            ostream << cv->getMangledTypeName() << "[" << index << "].offset = offsetof(" ;
            ostream << cv->getMangledTypeName() << "," << fdes->getName() << ") ;\n" ;
        } else {
            // else print an offsetof statement if this is not a special case
            ostream << "    attr" ;
            printNamespaces( ostream, cv , "__" ) ;
            printContainerClasses( ostream, cv , "__" ) ;
            ostream << cv->getMangledTypeName() << "[" << index << "].offset = offsetof(" ;
            printNamespaces( ostream, cv , "::" ) ;
            printContainerClasses( ostream, cv , "::" ) ;
            ostream << cv->getMangledTypeName() << "," << fdes->getName() << ") ;\n" ;
        }
    } else {
        if ( fdes->isStatic() ) {
            ostream << "    attr" ;
            printNamespaces( ostream, cv , "__" ) ;
            printContainerClasses( ostream, cv , "__" ) ;
            ostream << cv->getMangledTypeName() << "[" << index << "].offset = (long)(void *)&" ;
            printNamespaces( ostream, cv , "::" ) ;
            printContainerClasses( ostream, cv , "::" ) ;
            ostream << cv->getName() << "::" << fdes->getName() << " ;\n" ;
        }
    }

    if ( fdes->isSTL()) {
        ostream << "    attr" ;
        printNamespaces( ostream, cv , "__" ) ;
        printContainerClasses( ostream, cv , "__" ) ;
        ostream << cv->getMangledTypeName() << "[" << index << "].checkpoint_stl = checkpoint_stl_" ;
        printNamespaces( ostream, cv , "__" ) ;
        printContainerClasses( ostream, cv , "__" ) ;
        ostream << cv->getMangledTypeName() ;
        ostream << "_" ;
        ostream << fdes->getName() ;
        ostream << " ;\n" ;

        ostream << "    attr" ;
        printNamespaces( ostream, cv , "__" ) ;
        printContainerClasses( ostream, cv , "__" ) ;
        ostream << cv->getMangledTypeName() << "[" << index << "].post_checkpoint_stl = post_checkpoint_stl_" ;
        printNamespaces( ostream, cv , "__" ) ;
        printContainerClasses( ostream, cv , "__" ) ;
        ostream << cv->getMangledTypeName() ;
        ostream << "_" ;
        ostream << fdes->getName() ;
        ostream << " ;\n" ;

        ostream << "    attr" ;
        printNamespaces( ostream, cv , "__" ) ;
        printContainerClasses( ostream, cv , "__" ) ;
        ostream << cv->getMangledTypeName() << "[" << index << "].restore_stl = restore_stl_" ;
        printNamespaces( ostream, cv , "__" ) ;
        printContainerClasses( ostream, cv , "__" ) ;
        ostream << cv->getMangledTypeName() ;
        ostream << "_" ;
        ostream << fdes->getName() ;
        ostream << " ;\n" ;

        if (fdes->hasSTLClear()) {
            ostream << "    attr" ;
            printNamespaces( ostream, cv , "__" ) ;
            printContainerClasses( ostream, cv , "__" ) ;
            ostream << cv->getMangledTypeName() << "[" << index << "].clear_stl = clear_stl_" ;
            printNamespaces( ostream, cv , "__" ) ;
            printContainerClasses( ostream, cv , "__" ) ;
            ostream << cv->getMangledTypeName() ;
            ostream << "_" ;
            ostream << fdes->getName() ;
            ostream << " ;\n" ;
        }
    }

    if ( fdes->isRecord() or fdes->isEnum()) {
        ostream << "    trick_MM->add_attr_info(std::string(attr" ;
        printNamespaces( ostream, cv , "__" ) ;
        printContainerClasses( ostream, cv , "__" ) ;
        ostream << cv->getMangledTypeName() << "[" << index << "].type_name) , &attr"  ;
        printNamespaces( ostream, cv , "__" ) ;
        printContainerClasses( ostream, cv , "__" ) ;
        ostream << cv->getMangledTypeName() << "[" << index << "], __FILE__ , __LINE__ ) ;\n" ;
    }
}

/** Prints add_attr_info statements for each inherited class */
void PrintFileContents10::print_inherited_add_attr_info( std::ostream & ostream , ClassValues * cv ) {
    ClassValues::InheritedClassesIterator cit ;
    if ( cv->getNumInheritedClasses() > 0 ) {
        ostream << "\n    ATTRIBUTES temp_attr ;\n\n" ;
    }
    for ( cit = cv->inherit_classes_begin() ; cit != cv->inherit_classes_end() ; cit++ ) {
        ostream << "    trick_MM->add_attr_info( std::string(\"" << *cit << "\"), &temp_attr , __FILE__ , __LINE__ ) ;\n" ;
    }
}

/** Prints init_attr function for each class */
void PrintFileContents10::print_init_attr_func( std::ostream & ostream , ClassValues * cv ) {

    ClassValues::FieldIterator fit ;

    printOpenNamespaceBlocks(ostream, cv) ;
    ostream << "\nvoid init_attr" ;
    printNamespaces( ostream, cv , "__" ) ;
    printContainerClasses( ostream, cv , "__" ) ;
    ostream << cv->getMangledTypeName() ;
    ostream << "() {\n\n"
"    static int initialized ;\n"
"    if ( initialized ) {\n"
"            return ;\n"
"    }\n"
"    initialized = 1 ;\n\n" ;

    if ( cv->getMangledTypeName() != cv->getName() ) {
        ostream << "    typedef " << cv->getName() << " " << cv->getMangledTypeName() << " ;\n\n" ;
    }

#if 0
    if ( !global_compat15 and !cv->isCompat15()) {
        ostream << "    if ( sizeof(" ;
        printNamespaces( ostream, cv , "::" ) ;
        printContainerClasses( ostream, cv , "::" ) ;
        ostream << cv->getName() << ") > " << cv->getSize() << ") {\n" ;
        ostream << "        Trick::ClassSizeCheck::class_size_check()->add_diff(\"" ;
        printNamespaces( ostream, cv , "::" ) ;
        printContainerClasses( ostream, cv , "::" ) ;
        ostream << cv->getName() << "\" , Trick::ClassSizeDiffInfo((sizeof(" ;
        printNamespaces( ostream, cv , "::" ) ;
        printContainerClasses( ostream, cv , "::" ) ;
        ostream << cv->getName() << ") - " << cv->getSize() << ") , \"" << cv->getFileName() << "\")) ;\n" ;
        ostream << "    }\n" ;
    }
#endif

    unsigned int ii = 0 ;
    for ( fit = cv->field_begin() ; fit != cv->field_end() ; fit++ ) {
        if ( determinePrintAttr(cv , *fit) ) {
            print_field_init_attr_stmts(ostream, *fit, cv, ii) ;
            ii++ ;
        }
    }
    print_inherited_add_attr_info(ostream, cv ) ;
    ostream << "}\n" ;
    printCloseNamespaceBlocks(ostream, cv) ;
}

/** Prints the io_src_sizeof function for enumerations */
void PrintFileContents10::print_enum_io_src_sizeof( std::ostream & ostream , EnumValues * ev ) {
    print_open_extern_c(ostream) ;
    ostream << "size_t io_src_sizeof_" ;
    printNamespaces( ostream, ev , "__" ) ;
    printContainerClasses( ostream, ev , "__" ) ;
    ostream << ev->getName() << "( void ) {\n" ;
    if ( ev->getHasDefinition() ) {
        ostream << "    return( sizeof(" ;
        printNamespaces( ostream, ev , "::" ) ;
        printContainerClasses( ostream, ev , "::" ) ;
        ostream << ev->getName() << "));\n}\n" ;
    } else {
        ostream << "    return(sizeof(int)) ;\n}\n" ;
    }
    print_close_extern_c(ostream) ;
}

/** Prints the C linkage init_attr function */
void PrintFileContents10::print_init_attr_c_intf( std::ostream & ostream , ClassValues * cv ) {
    ostream << "void init_attr" ;
    printNamespaces( ostream, cv , "__" ) ;
    printContainerClasses( ostream, cv , "__" ) ;
    ostream << cv->getMangledTypeName() << "_c_intf() {\n    " ;
    printNamespaces( ostream, cv , "::" ) ;
    ostream << "init_attr" ;
    printNamespaces( ostream, cv , "__" ) ;
    printContainerClasses( ostream, cv , "__" ) ;
    ostream << cv->getMangledTypeName() << "() ;\n"
"}\n\n" ;
}

/** Prints the io_src_sizeof function */
void PrintFileContents10::print_io_src_sizeof( std::ostream & ostream , ClassValues * cv ) {
    ostream << "size_t io_src_sizeof_" ;
    printNamespaces( ostream, cv , "__" ) ;
    printContainerClasses( ostream, cv , "__" ) ;
    ostream << cv->getMangledTypeName() << "( void ) {\n" ;
    ostream << "    return( sizeof(" ;
    // Template types
    if ( cv->getMangledTypeName() == cv->getName() ) {
        printNamespaces( ostream, cv , "::" ) ;
        printContainerClasses( ostream, cv , "::" ) ;
    }
    ostream << cv->getName() << ") );\n}\n\n" ;
}

/** Prints the io_src_allocate function */
void PrintFileContents10::print_io_src_allocate( std::ostream & ostream , ClassValues * cv ) {
    if ( cv->isPOD() or (! cv->isAbstract() and cv->getHasDefaultConstructor()) ) {
        ostream << "void * io_src_allocate_" ;
        printNamespaces( ostream, cv , "__" ) ;
        printContainerClasses( ostream, cv , "__" ) ;
        ostream << cv->getMangledTypeName() << "( int num) {\n" ;

        ostream << "    " ;
        if ( cv->getMangledTypeName() == cv->getName() ) {
            printNamespaces( ostream, cv , "::" ) ;
            printContainerClasses( ostream, cv , "::" ) ;
        }
        ostream << cv->getName() << " * temp = (" ;
        if ( cv->getMangledTypeName() == cv->getName() ) {
            printNamespaces( ostream, cv , "::" ) ;
            printContainerClasses( ostream, cv , "::" ) ;
        }
        ostream << cv->getName() << " * )calloc( num, sizeof(" ;
        if ( cv->getMangledTypeName() == cv->getName() ) {
            printNamespaces( ostream, cv , "::" ) ;
            printContainerClasses( ostream, cv , "::" ) ;
        }
        ostream << cv->getName() << "));\n" ;
        if ( ! cv->isPOD() ) {
            ostream << "    for (int ii=0 ; ii<num ; ii++) {\n" ;
            ostream << "        new( &temp[ii]) " ;
            if ( cv->getMangledTypeName() == cv->getName() ) {
                printNamespaces( ostream, cv , "::" ) ;
                printContainerClasses( ostream, cv , "::" ) ;
            }
            ostream << cv->getName() << "();\n" << "    }\n" ;
        }
        ostream << "    return ((void *)temp);\n" << "}\n\n" ;
    }
}

/** Prints the io_src_allocate function */
void PrintFileContents10::print_io_src_destruct( std::ostream & ostream , ClassValues * cv ) {
    if ( cv->getHasPublicDestructor()) {
        ostream << "void io_src_destruct_" ;
        printNamespaces( ostream, cv , "__" ) ;
        printContainerClasses( ostream, cv , "__" ) ;
        ostream << cv->getMangledTypeName() << "( void * addr __attribute__((unused)), int num __attribute__((unused)) ) {\n" ;
        if ( ! cv->isPOD() ) {
            // Add a using statement so we can call the destructor without fully qualifying it.
            ClassValues::NamespaceIterator nsi = cv->namespace_begin() ;
            if ( nsi != cv->namespace_end() ) {
                ostream << "    using namespace " ;
                while ( nsi != cv->namespace_end() ) {
                    ostream << *nsi ;
                    nsi++ ;
                    if ( nsi != cv->namespace_end()) {
                        ostream << "::" ;
                    }
                }
                ostream << " ;\n" ;
            }
            ostream << "    " ;
            if ( cv->getMangledTypeName() == cv->getName() ) {
                printNamespaces( ostream, cv , "::" ) ;
                printContainerClasses( ostream, cv , "::" ) ;
            }
            ostream << cv->getName() << " * temp = (" ;
            if ( cv->getMangledTypeName() == cv->getName() ) {
                printNamespaces( ostream, cv , "::" ) ;
                printContainerClasses( ostream, cv , "::" ) ;
            }
            ostream << cv->getName() << " * )addr ;\n" ;
            ostream << "    for (int ii=0 ; ii<num ; ii++) {\n" ;
            if ( cv->getMangledTypeName() == cv->getName() ) {
                ostream << "        temp[ii].~" ;
                ostream << cv->getName() << "();\n" ;
            }
            ostream << "    }\n" ;
        }
        ostream << "}\n\n" ;
    }
}

void PrintFileContents10::print_io_src_delete( std::ostream & ostream , ClassValues * cv ) {
    if ( cv->getHasPublicDestructor()) {
        ostream << "void io_src_delete_" ;
        printNamespaces( ostream, cv , "__" ) ;
        printContainerClasses( ostream, cv , "__" ) ;
        ostream << cv->getMangledTypeName() << "( void * addr " ;
        if ( ! cv->isPOD() ) {
            ostream << ") {\n" ;
            ostream << "    delete (" ;
            if ( cv->getMangledTypeName() == cv->getName() ) {
                printNamespaces( ostream, cv , "::" ) ;
                printContainerClasses( ostream, cv , "::" ) ;
            }
            ostream << cv->getName() << "*)addr ;\n" ;
        }
        else {
            ostream << "__attribute__((unused)) ) {" ;
        }
        ostream << "}\n" ;
    }
}

void PrintFileContents10::print_stl_helper_proto(std::ostream & ostream , ClassValues * cv ) {
    std::ostringstream oss;

    for ( ClassValues::FieldIterator fit = cv->field_begin() ; fit != cv->field_end() ; fit++ ) {
        if ( (*fit)->isSTL() and determinePrintAttr(cv , *fit) ) {
            oss << "void checkpoint_stl_" ;
            printNamespaces( oss, cv , "__" ) ;
            printContainerClasses( oss, cv , "__" ) ;
            oss << cv->getMangledTypeName() ;
            oss << "_" ;
            oss << (*fit)->getName() ;
            oss << "(void * start_address, const char * obj_name , const char * var_name) ;" << std::endl ;

            oss << "void post_checkpoint_stl_" ;
            printNamespaces( oss, cv , "__" ) ;
            printContainerClasses( oss, cv , "__" ) ;
            oss << cv->getMangledTypeName() ;
            oss << "_" ;
            oss << (*fit)->getName() ;
            oss << "(void * start_address, const char * obj_name , const char * var_name) ;" << std::endl ;

            oss << "void restore_stl_" ;
            printNamespaces( oss, cv , "__" ) ;
            printContainerClasses( oss, cv , "__" ) ;
            oss << cv->getMangledTypeName() ;
            oss << "_" ;
            oss << (*fit)->getName() ;
            oss << "(void * start_address, const char * obj_name , const char * var_name) ;" << std::endl ;

            if ((*fit)->hasSTLClear()) {
                oss << "void clear_stl_" ;
                printNamespaces( oss, cv , "__" ) ;
                printContainerClasses( oss, cv , "__" ) ;
                oss << cv->getMangledTypeName() ;
                oss << "_" ;
                oss << (*fit)->getName() ;
                oss << "(void * start_address) ;" << std::endl ;
            }
        }
    }

    std::string text = oss.str();
    if (text.size()) {
        print_open_extern_c(ostream) ;
        ostream << text;
        print_close_extern_c(ostream) ;
    }
}

void PrintFileContents10::print_checkpoint_stl(std::ostream & ostream , FieldDescription * fdes , ClassValues * cv ) {
    ostream << "void checkpoint_stl_" ;
    printNamespaces( ostream, cv , "__" ) ;
    printContainerClasses( ostream, cv , "__" ) ;
    ostream << cv->getMangledTypeName() ;
    ostream << "_" ;
    ostream << fdes->getName() ;
    ostream << "(void * start_address, const char * obj_name , const char * var_name) {" << std::endl ;

    ostream << "    " << fdes->getTypeName() << " * stl = reinterpret_cast<" << fdes->getTypeName() << " * >(start_address) ;" << std::endl ;
    ostream << "    " << "checkpoint_stl(*stl , obj_name , var_name) ;" << std::endl ;

    ostream << "}" << std::endl ;
}

void PrintFileContents10::print_post_checkpoint_stl(std::ostream & ostream , FieldDescription * fdes , ClassValues * cv ) {
    ostream << "void post_checkpoint_stl_" ;
    printNamespaces( ostream, cv , "__" ) ;
    printContainerClasses( ostream, cv , "__" ) ;
    ostream << cv->getMangledTypeName() ;
    ostream << "_" ;
    ostream << fdes->getName() ;
    ostream << "(void * start_address, const char * obj_name , const char * var_name) {" << std::endl ;

    ostream << "    " << fdes->getTypeName() << " * stl = reinterpret_cast<" << fdes->getTypeName() << " * >(start_address) ;" << std::endl ;
    ostream << "    " << "delete_stl(*stl , obj_name , var_name) ;" << std::endl ;

    ostream << "}" << std::endl ;
}

void PrintFileContents10::print_restore_stl(std::ostream & ostream , FieldDescription * fdes , ClassValues * cv ) {
    ostream << "void restore_stl_" ;
    printNamespaces( ostream, cv , "__" ) ;
    printContainerClasses( ostream, cv , "__" ) ;
    ostream << cv->getMangledTypeName() ;
    ostream << "_" ;
    ostream << fdes->getName() ;
    ostream << "(void * start_address, const char * obj_name , const char * var_name) {" << std::endl ;

    ostream << "    " << fdes->getTypeName() << " * stl = reinterpret_cast<" << fdes->getTypeName() << " * >(start_address) ;" << std::endl ;
    ostream << "    " << "restore_stl(*stl , obj_name , var_name) ;" << std::endl ;

    ostream << "}" << std::endl ;
}

void PrintFileContents10::print_clear_stl(std::ostream & ostream , FieldDescription * fdes , ClassValues * cv ) {
    ostream << "void clear_stl_" ;
    printNamespaces( ostream, cv , "__" ) ;
    printContainerClasses( ostream, cv , "__" ) ;
    ostream << cv->getMangledTypeName() ;
    ostream << "_" ;
    ostream << fdes->getName() ;
    ostream << "(void * start_address) {" << std::endl ;

    ostream << "    " << fdes->getTypeName() << " * stl = reinterpret_cast<" << fdes->getTypeName() << " * >(start_address) ;" << std::endl ;
    ostream << "    " << "stl->clear() ;" << std::endl ;

    ostream << "}" << std::endl ;
}

void PrintFileContents10::print_stl_helper(std::ostream & ostream , ClassValues * cv ) {
    std::ostringstream oss;

    for ( ClassValues::FieldIterator fit = cv->field_begin() ; fit != cv->field_end() ; fit++ ) {
        if ( (*fit)->isSTL() and determinePrintAttr(cv , *fit) ) {
            print_checkpoint_stl(oss , *fit, cv) ;
            print_post_checkpoint_stl(oss , *fit, cv) ;
            print_restore_stl(oss , *fit, cv) ;
            if ((*fit)->hasSTLClear()) {
                print_clear_stl(oss , *fit, cv) ;
            }
        }
    }

    std::string text = oss.str();
    if (text.size()) {
        print_open_extern_c(ostream) ;
        ostream << text;
        print_close_extern_c(ostream) ;
    }
}

void PrintFileContents10::printClass( std::ostream & ostream , ClassValues * cv ) {
    print_stl_helper_proto(ostream, cv) ;
    print_class_attr(ostream, cv) ;
    print_stl_helper(ostream, cv) ;
    print_init_attr_func(ostream, cv) ;
    ostream << std::endl;
    print_open_extern_c(ostream) ;
    print_init_attr_c_intf(ostream, cv) ;
    print_io_src_sizeof(ostream, cv) ;
    print_io_src_allocate(ostream, cv) ;
    print_io_src_destruct(ostream, cv) ;
    print_io_src_delete(ostream, cv) ;
    print_close_extern_c(ostream) ;
    print_units_map(ostream, cv) ;
}

void PrintFileContents10::printEnum( std::ostream & ostream , EnumValues * ev ) {
    print_enum_attr(ostream, ev) ;
    print_enum_io_src_sizeof(ostream, ev) ;
}

void PrintFileContents10::printClassMapHeader( std::ostream & ostream , std::string function_name ) {
     ostream <<
"/*\n"
" * This file was automatically generated by the ICG\n"
" * This file contains the map from class/struct names to attributes\n"
" */\n\n"
"#include <map>\n"
"#include <string>\n\n"
"#include \"trick/AttributesMap.hh\"\n"
"#include \"trick/EnumAttributesMap.hh\"\n"
"#include \"trick/attributes.h\"\n\n"
"void " << function_name << "() {\n\n"
"    Trick::AttributesMap * class_attribute_map = Trick::AttributesMap::attributes_map();\n\n" ;
}

void PrintFileContents10::printClassMap( std::ostream & ostream , ClassValues * cv ) {
    ostream << "    // " << cv->getFileName() << std::endl ;
    ostream << "    extern ATTRIBUTES  attr" ;
    printNamespaces( ostream, cv , "__" ) ;
    printContainerClasses( ostream, cv , "__" ) ;
    ostream << cv->getMangledTypeName() << "[] ;" << std::endl ;

    ostream << "    class_attribute_map->add_attr(\"" ;
    printNamespaces( ostream, cv , "::" ) ;
    printContainerClasses( ostream, cv , "::" ) ;
    ostream << cv->getMangledTypeName() << "\" , attr" ;
    printNamespaces( ostream, cv , "__" ) ;
    printContainerClasses( ostream, cv , "__" ) ;
    ostream << cv->getMangledTypeName() << ") ;" << std::endl ;
}

void PrintFileContents10::printClassMapFooter( std::ostream & ostream ) {
     ostream << "}" << std::endl << std::endl ;
}

void PrintFileContents10::printEnumMapHeader( std::ostream & ostream , std::string function_name ) {
     ostream <<
"void " << function_name << "() {\n"
"    Trick::EnumAttributesMap * enum_attribute_map __attribute__((unused)) = Trick::EnumAttributesMap::attributes_map();\n\n" ;
}

void PrintFileContents10::printEnumMap( std::ostream & ostream , EnumValues * ev ) {
    ostream << "    extern ENUM_ATTR  enum" ;
    printNamespaces( ostream, ev , "__" ) ;
    printContainerClasses( ostream, ev , "__" ) ;
    ostream << ev->getName() << "[] ;" << std::endl ;

    ostream << "    enum_attribute_map->add_attr(\"" ;
    printNamespaces( ostream, ev , "::" ) ;
    printContainerClasses( ostream, ev , "::" ) ;
    ostream << ev->getName() << "\" , enum" ;
    printNamespaces( ostream, ev , "__" ) ;
    printContainerClasses( ostream, ev , "__" ) ;
    ostream << ev->getName() << ") ;" << std::endl ;
}

void PrintFileContents10::printEnumMapFooter( std::ostream & ostream ) {
     ostream << "}" << std::endl << std::endl ;
}
